<!DOCTYPE html>
<html>
    <head>
        <title>Курс 1.1</title>
        <meta charset="utf-8">
        <style>
            body {
                text-align: center;
                font-size: 16px;
                width: 80%;
                margin-right: auto;
                margin-left: auto;
                background: #0c333a;     
            }

            #main-header {
                border: 2px solid rgb(129, 37, 37);
            }

            .title {
                background: #7abcfa;
                height: 60px;
                text-align: left;
                border: 1px solid rgb(44, 81, 247);
                border-left: 10px solid rgb(44, 81, 247);
                margin-top: 15px;
                margin-bottom: 1px;    
            }

            h2 {
                color: rgb(0, 17, 167);
            }

            article {
                background: #f1fdff;
                text-align: left;
                padding: 10px;
            }
            
            aside {
                float: right;
                border: 1px solid rgb(129, 37, 37);
                height: 200px;
                padding: 10px;
                margin: 10px;
            }

            .table-borders1 {
                border: 5px solid black;
                border-collapse: collapse;
            }

            .table-borders1 td {
                border: 3px solid lightgray;
            }

            .table-borders2 {
                border: 3px solid black;
                border-collapse: separate;
                border-spacing: 5px;
                width: 700px;
                height: 400px;
            }

            .table-borders2 td {
                border-bottom: 2px solid lightgray;
                border-left: 2px solid lightgray; 
                padding: 5px;
                padding-right: 30px;
            }

            .cell-1 {
                vertical-align: top;
            }

            .column-2 {
                text-align: right;
                color: brown;
                background-color: lightyellow;
            }

            .column-3 {
                text-align: center;
                color: darkblue;
                background-color: lightcyan;
            }

            .table-headers {
                border-collapse: collapse;
                border: 2px solid black;
            }

            .table-headers td {
                padding: 5px;
                padding-right: 30px;
                border: 1px solid lightgray;
            }

            .table-headers th {
                padding: 10px;
                border: 1px solid black;
            }

            .table-headers caption {
                text-align: center;
                caption-side: bottom;
            }

            .table-merge {
                border-collapse: separate;
                border: 2px solid black;
                border-spacing: 4px;
            }

            .table-merge td {
                padding: 5px;
                padding-right: 30px;
                border: 1px solid lightgray;
            }

            .table-merge th {
                padding: 10px;
                border: 1px solid black;
            }

            .table-merge caption {
                margin-bottom: 10px;
                font-size: 18px;
            }

            .pink {
                background-color: pink; 
            }
        </style>
    </head>

    <body>
        <header id="main-header">
            <h1>WDT HEADER</h1>
        </header>
            
        <main>
            <section>
                <header class="title">
                    <h1>HTML</h1>
                </header>
                
                <aside>
                    <p>ASIDE ASIDE ASIDE ASIDE </p>
                </aside>
                
                <article>
                    <p>&lt;h1&gt; - Заголовок первого уровня (block, paired)</p>
                    <p>&lt;p&gt; - параграф (block, paired)</p>
                    <p>&lt;!-- комментарий хтмл --&gt;</p>
                    <p>&lt;strong&gt; - выделяет болдом (inline, paired)</p>
                    <p>&lt;br&gt; - перевод строки (void)</p>
                    <p>&lt;img&gt; - добавление изображения (inline, void) // attributes (src="путь к файлу" alt="текст отображающийся если картинка не загрузилась")</p>
                    <p>&lt;hr&gt; - разделительная линия (void)</p>
                    <p>&lt;link rel="stylesheet" href="style.css"&gt; - подключение внешнего файла CSS</p>
                    <p>&lt;!doctype html&gt; - стандарт декларации типа документа</p>
                    <p>&lt;html&gt; - контейнер в котором находится весь документ</p>
                    <p>&lt;head&gt; - контейнер элементов данных документа</p>
                    <p>&lt;body&gt; - контейнер содержащий контент страницы</p>
                    <p>&lt;title&gt; - заголовок страницы в окне браузера</p>
                    <p>&lt;meta charset="utf-8"&gt; - указание кодировки страницы</p>
                    <p>&lt;meta name="keywords" content=" "&gt; - описание ключевых слов страницы для поисковиков</p>
                    <p>&lt;meta name="description" content=" "&gt; - краткое содержание страницы для поисковиков</p>
                    <p>&lt;style&gt; - тег для инлайновых стилей размещающийся в head (не лучшая практика)</p>
                    <p>&lt;script&gt; - содержит js, атрибут src=" " подключает внешний js (лучше размещать в конце body, если не onLoad скрипт)</p>
                    <p>&lt;strong&gt; - определяет важность отмеченного текста.</p>
                    <p>&lt;b&gt; - предназначен для <b>выделения текста</b> без придания ему особой важности</p>
                    <p>&lt;em&gt; - выделяет <em>курсивом</em>, добавляет важность (inline, paired)</p>
                    <p>&lt;i&gt; - выделяет <i>курсивом</i> без придания важности</p>
                    <p>&lt;blockquote&gt; - предназначен для выделения длинных цитат, которые могут состоять из нескольких абзацев. Тег выделяет цитату как отдельный блок текста с отступами.</p>
                    <p>&lt;q&gt; - предназначен для выделения коротких цитат в предложениях. Текст внутри этого тега автоматически обрамляется кавычками.</p>
                    <p>&lt;cite&gt; - используется для того, чтобы выделить источник цитаты, название произведения или автора цитаты.</p>
                    <p>&lt;sup&gt; - отображает текст в виде верхнего индекса</p>
                    <p>&lt;sub&gt; - отображает текст в виде нижнего индекса</p>
                    <p>&lt;del&gt; - выделяет текст, который был удалён в новой версии документа.</p>
                    <p>&lt;ins&gt; - выделяет текст, который был добавлен в новой версии документа</p>
                    <p>Оба тега имеют атрибут datetime, в котором можно указать дату и время, когда была внесена та или иная правка.</p>
                    <p>&lt;pre&gt; - обозначает «предварительно отформатированный текст». Браузер сохраняет и отображает все пробелы и переносы, которые есть внутри тега</p>
                    <p>&lt;mark&gt; - обозначает выделенный текст, подсвечивается жёлтым фоном</p>
                </article>
                <article>
                    <h2>Списки</h2>
                    <p>&lt;ul&gt; - неупорядоченный список</p>
                    <p>&lt;ol&gt; - нумерованный список (start=" " изменяет начало нумерации)</p>
                    <p>&lt;li&gt; - элемент списка</p>
                    <p>&lt;dl&gt; - список определений</p>
                    <p>&lt;dt&gt; - термин</p>
                    <p>&lt;dd&gt; - определение</p>
                </article>
        
                <article>
                    <h2>Ссылки</h2>
                    <p>&lt;a&gt; - ссылки создаются с помощью очень простого и короткого тега</p>
                    <p>href=" " - Адрес ссылки задаётся с помощью атрибута</p>
                    
                    <h3>Абсолютные адреса</h3>
                    <p>Абсолютные адреса содержат в себе протокол, имя сервера и путь.</p>
                    <p>https:// - это протокол</p>
                    <p>krot.eu - имя сервера, также называется домен или хост</p>
                    <p>/nora - путь</p>

                    <h3>Относительные адреса</h3>
                    <ul class="list">
                        <li>courses/1</li>
                        <li>./courses</li>
                        <li>../../run/1</li>
                    </ul>
                    <p>В относительных адресах могут использоваться специальные символы, аналогичные символам в путях файловых систем: . и ...</p>
                    <p>Использовать относительные адреса для навигации по сайту не рекомендуется. Однако относительные адреса бывают полезны, например, во внешних CSS-файлах.</p>
                    
                    <h3>Ссылка на файл</h3>
                    <p>Ссылка может указывать на любую веб-страницу, на любой файл. Если щёлкнуть по ссылке, ведущей на файл, то браузер предложит его скачать.</p>
                    <p>Однако, если браузер умеет обрабатывать файлы этого типа, то содержимое файла откроется прямо в браузере. Чаще всего так происходит с изображениями. В последнее время браузеры научились открывать .pdf файлы и многие другие.</p>
                    <p>&lt;a href="file.rtf"&gt;Скачать простой текстовый файл&lt;/a&gt;</p>

                    <h3>Ссылка с якорем</h3>
                    <p>Ссылки с якорем обычно используются для создания навигации внутри страницы. Например, оглавления в начале страницы с большой статьёй.</p>
                    <p>Ссылка с якорем содержит символ #, после которого идёт идентификатор. Идентификатор создаётся с помощью атрибута id, который может быть задан у любого тега.</p>
                    <p>&lt;a href="#glava1"&gt;</p>

                    <h3>Всплывающая подсказка</h3>
                    <p>Для того, чтобы добавить ссылке всплывающую подсказку, надо использовать атрибут title.</p>
                    <p>&lt;a title="Подсказка" href="#"&gt;</p>

                    <h2>Изображения</h2>
                    <h3>Добавление изображения</h3>
                    <p>Чтобы добавить на страницу изображение, нужно использовать одиночный тег &lt;img&gt; с атрибутом src, в котором указан адрес картинки.</p>
                    <p>&lt;img src="logo.png"&gt;</p>

                    <h3>Размеры изображения</h3>
                    <p>Чтобы управлять шириной или высотой изображения, нужно использовать атрибуты width и height.</p>
                    <p>&lt;img width="100" src="..."&gt;</p>
                    <p>В примере изображению задана ширина 100px. Обратите внимание, что в атрибуте width после цифры нет px. Если вы задаёте размер картинки в пикселях, то используйте просто цифры. Добавлять px не нужно, таков стандарт.</p>
                    <p>Во втором примере изображению задана относительная ширина, 50 процентов:</p>
                    <p>&lt;img width="50%" src="..."&gt;</p>
                    <p>Высоту в процентах обычно не задают. Если задать только один из размеров, ширину или высоту, то вторую размерность браузер вычислит самостоятельно исходя из пропорций изображения.</p>
                    <p>Если же задать и ширину, и высоту для картинки:</p>
                    <p>&lt;img width="100" height="100" src="..."&gt;</p>
                    <p>То браузер может нарушить пропорции исходного изображения.</p>

                    <h3>Альтернативный текст</h3>
                    <p>Если у пользователя отключены изображения или их невозможно загрузить, то в браузере отображается альтернативный текст. Например, если меню сделано с помощью изображений, то альтернативный текст поможет понять, куда ведёт каждый пункт. В общем, задавать альтернативный текст хорошо.</p>
                    <p>Альтернативный текст изображения задаётся с помощью атрибута alt.</p>
                    <p>&lt;img src="cat.png" alt=" "&gt;</p>

                    <h3>Изображение-ссылка</h3>
                    <p>Ссылки можно делать не только с помощью текста, но и с помощью изображений. Для этого нужно обернуть тег &lt;img&gt; в тег &lt;a&gt;</a></p>
                    <p>Часто ссылки-изображения используются в галереях, когда с уменьшенной версии изображения ставится ссылка на полноразмерное изображение.</p>

                    <h2>Таблицы</h2>
                    <p>&lt;table&gt; - обозначает таблицу</p>
                    <p>&lt;tr&gt; - расшифровывается как «table row», обозначает строку таблицы</p>
                    <p>&lt;td&gt; - расшифровывается как «table data», обозначает ячейку внутри строки таблицы</p>
                    <p>Теги &lt;td&gt; располагаются внутри тегов &lt;tr&gt;, а те, в свою очередь, внутри &lt;table&gt;. Почти всё текстовое содержимое таблицы размещается внутри тегов &lt;td&gt;&lt;/td&gt;</p>
                    <p>В простейшей таблице в каждой строке должно быть одинаковое количество ячеек, то есть внутри всех &lt;tr&gt; должно быть одинаковое количество &lt;td&gt;</p>
                        <div class="table">
                            <table class="table-borders1">
                                <tr>
                                    <td>Row 1 Col 1</td>
                                    <td>Row 1 Col 2</td>
                                    <td>Row 1 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td>Row 2 Col 2</td>
                                    <td>Row 2 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td>Row 2 Col 2</td>
                                    <td>Row 2 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td>Row 2 Col 2</td>
                                    <td>Row 2 Col 3</td>
                                </tr>
                            </table>
                        </div>
                    
                    <h2>CSS для таблиц</h2>
                    <p>С помощью CSS-свойства border можно задавать как внешние рамки таблицы, так и рамки каждой ячейки</p>
                    <p>По умолчанию браузер рисует рамки таблицы и рамки отдельных ячеек раздельно, это отлично видно на примере. Чтобы избавиться от таких двойных рамок, используется CSS-свойство таблицы border-collapse. Значение collapse убирает двойные рамки: cхлопываются рамки соседних ячеек, а также рамки ячеек и внешняя рамка таблицы. При этом внешняя рамка таблицы может исчезнуть, и чтобы её вернуть, можно увеличить её ширину.</p>

                    <h3>Горизонтальные и вертикальные рамки</h3>
                    <p>Иногда требуется, чтобы рамки ячеек в таблице отображались не полностью. Например, чтобы отображалась только нижняя рамка ячеек, тогда таблица получается расчерченной по горизонтали. Аналогично, если отображать только боковые рамки ячеек, то таблица получается разбитой на столбцы.</p>
                    <p>Такие эффекты легко достигаются с помощью CSS. Для этого необходимо использовать не свойство border, которое задаёт рамки для всех сторон ячейки, а одно из свойств:</p>

                        <ul class="list">
                            <li>border-top</li>
                            <li>border-right</li>
                            <li>border-bottom</li>
                            <li>border-left</li>
                        </ul>

                    <p>CSS-свойство padding задаёт «внутренние отступы элемента» со всех сторон. Можно задавать отступы для каждой из сторон отдельно, используя свойства:</p>

                        <ul class="list">
                            <li>padding</li>
                            <li>padding-top</li>
                            <li>padding-right</li>
                            <li>padding-bottom</li>
                            <li>padding-left</li>
                        </ul>

                    <p>Помимо внутренних отступов можно задавать отступы между ячейками таблицы.</p>
                    <p>Отступы между ячейками не работают с border-collapse: collapse, что достаточно логично, ведь рамки ячеек в этом режиме «склеены» и их не разорвать. Используем border-collapse: separate, которое «расклеивает» ячейки. На самом деле это значение по умолчанию, используем его только для наглядности. Если удалить свойство border-collapse, то результат не изменится, ячейки будут отображаться раздельно.</p>
                    <p>Отступы между ячейками можно задать c помощью CSS-свойства border-spacing. Свойство border-spacing задаётся для таблицы, в отличие от padding, которое задаётся для ячеек.</p> 
                    
                    <h3>Выравнивание содержимого в ячейках</h3>
                    <p>Содержимое ячеек можно выравнивать по горизонтали и по вертикали с помощью CSS. За выравнивание по горизонтали отвечает CSS-свойство text-align. Чаще всего используются значения left, center и right. За выравнивание по вертикали отвечает CSS-свойство vertical-align. Чаще всего используются значения top, middle и bottom. На самом деле, значений у обоих свойств больше, но в случае с ячейками нас интересуют только перечисленные.</p>
                        
                    <h3>Добавление цвета</h3>
                    <p>Таблицы можно раскрашивать, задавая цвет фона ячеек, цвет текста в ячейках, а также цвет рамок. Цветами можно управлять с помощью этих свойств:</p>
                        
                        <ul class="list">
                            <li>background-color - цвет фона</li>
                            <li>color - цвет текста</li>
                            <li>border-color: 1px solid "color"</li>
                        </ul>    

                    <h3>Размеры таблиц</h3>
                    <p>По умолчанию ширина и высота таблицы зависит от содержимого и отступов внутри ячеек. Чем меньше содержимого, тем меньше размеры таблицы. С помощью CSS можно управлять размерами таблицы, задавать желаемую ширину и высоту. Стоит отметить, что у таблицы есть минимальные размеры, которые зависят от содержания, меньше которых она не сожмётся, какое бы значение ширины или высоты ни задавалось. Ширина таблицы задаётся с помощью CSS-свойства width, а высота с помощью свойства height. Размеры таблицы можно задавать как в абсолютных единицах, например, в пикселях — 20px, так и в относительных, в процентах — 20%. При использовании процентов размеры таблицы будут вычисляться с учётом размеров родительского элемента. Особое значение auto включает расчёт размеров по умолчанию. Например, width: auto; или height: auto;</p>

                    <p><strong>Важное замечание</strong>. Проценты при задании высоты обычно <em>не работают</em>.</p>

                    <h3>Размеры отдельных ячеек и столбцов</h3>
                    <p>Размеры ячеек и столбцов тоже можно задавать вручную, особенно если вам не нравится, как браузер распределил ширину колонок. Размеры ячеек задаются точно так же, как и размеры таблицы: с помощью CSS-свойств width и height.</p>
                    <p>Есть два варианта добавления стилей ячейкам:

                        <ol>
                            <li>Назначать ячейкам уникальные имена классов, например, class="cell-11", и применять стили для этих классов.</li>
                            <li>Использовать атрибут style, внутри которого можно писать CSS-код.</li>
                        </ol>
                    </p>
                    <p>К счастью, редко нужно задавать размеры каждой ячейки. Обычно размеры ячеек прописывают, когда надо вручную установить ширину столбцов таблицы: для этого достаточно задать ширину для каждой ячейки из первой строки.</p>

                        <div class="table">
                            <table class="table-borders2">
                                <tr>
                                    <td class="cell-1">Row 1 Col 1</td>
                                    <td>Row 1 Col 2</td>
                                    <td>Row 1 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td class="column-2">Row 2 Col 2</td>
                                    <td class="column-3">Row 2 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td class="column-2">Row 2 Col 2</td>
                                    <td class="column-3">Row 2 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td class="column-2">Row 2 Col 2</td>
                                    <td class="column-3">Row 2 Col 3</td>
                                </tr>
                            </table>
                        </div>
                
                    <h3>Ячейки-заголовки</h3>
                    <p>Обычно в таблицах выделяют названия столбцов или строк. В HTML для этого предусмотрен специальный тег &lt;th&gt;, который расшифровывается как «table header» и обозначает ячейку-заголовок. Тег &lt;th&gt; аналогичен &lt;td&gt;, он так же должен располагаться внутри &lt;tr&gt;, для него стилями можно задавать все те же свойства.</p>
                    <p>По умолчанию текст внутри &lt;th&gt; выделяется жирным и выравнивается по центру ячейки.</p>
                    
                    <h3>Заголовок таблицы</h3>
                    <p>Семантически правильнее будет сделать это название с помощью тега &lt;caption&gt;. Тег &lt;caption&gt; должен размещаться внутри тега &lt;table&gt;, причём непосредственно внутри него и первым, до остальных вложенных тегов.</p>
                    <p>Тег заголовка идёт первым внутри таблицы, но с помощью CSS можно переместить заголовок таблицы в любое место: сверху или снизу таблицы, по центру, справа или слева.</p>
                    <p>По вертикали заголовок таблицы перемещается CSS-свойством caption-side со значениями top и bottom, которые обозначают до и после таблицы соответственно. По горизонтали заголовок таблицы выравнивается CSS-свойством text-align со значениями left, right и center.</p>

                        <div class="table">
                            <table class="table-headers">
                                <caption>Caption</caption>
                                <tr>
                                    <th>Row 1 Col 1</th>
                                    <th>Row 1 Col 2</th>
                                    <th>Row 1 Col 3</th>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td>Row 2 Col 2</td>
                                    <td>Row 2 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td>Row 2 Col 2</td>
                                    <td>Row 2 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 2 Col 1</td>
                                    <td>Row 2 Col 2</td>
                                    <td>Row 2 Col 3</td>
                                </tr>
                            </table>
                        </div>
                    
                    <h3>Объединение ячеек в строках</h3>
                    <p>Начнём с объединения ячеек по горизонтали. Чтобы объединить ячейки по горизонтали, необходимо использовать атрибут colspan у тегов &lt;th&gt; или &lt;td&gt;. Когда вы задаёте ячейке атрибут colspan со значением 2, то ячейка как бы «растягивается» на ячейку справа, но та ячейка не исчезает, а отодвигается и в таблице появляется новый столбец. Чтобы удалить его, нужно удалить ячейку, которая находится справа от «растянутой».</p>
                
                    <h3>Объединение ячеек в столбцах</h3>
                    <p>Объединение ячеек по вертикали немного сложнее. Оно осуществляется с помощью атрибута rowspan у тега &lt;td&gt; или &lt;th&gt;.</p>
                    <p>Когда вы задаёте ячейке атрибут rowspan со значением 2, то ячейка как бы «растягивается» на следующую строку. При этом ячейка, которая была под «растянутой» отодвигается в своей же строке вправо, что добавляет в таблицу лишний столбец. Удалив ячейку, которая была под «растянутой» мы избавимся от этого столбца.</p>

                        <div class="table">
                            <table class="table-merge">
                                <caption>Caption</caption>
                                <tr>
                                    <th rowspan="2">Rowspan 2 Col 1</th>
                                    <th colspan="2">Row 1 Colspan 2</th>
                                    <!-- <th class="pink">Row 1 Col 3</th>  colspan=2 занимает 2 столбца, этот становится четвертым и вылезает за таблицу -->
                                </tr>
                                <tr>
                                    <!-- <th class="pink">Row 2 Col 1</th>  rowspan выдавливает ячейки снизу в следующий столбец, который сдвигает все остальные-->
                                    <th>Row 2 Col 2</th>
                                    <th>Row 2 Col 3</th>
                                </tr>
                                <tr>
                                    <td>Row 3 Col 1</td>
                                    <td>Row 3 Col 2</td>
                                    <td>Row 3 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 4 Col 1</td>
                                    <td>Row 4 Col 2</td>
                                    <td>Row 4 Col 3</td>
                                </tr>
                                <tr>
                                    <td>Row 5 Col 1</td>
                                    <td>Row 5 Col 2</td>
                                    <td>Row 5 Col 3</td>
                                </tr>
                            </table>
                        </div>
                
                    <h2>Формы</h2>
                    
                    <h3>Первая форма</h3>
                    <p>Формы нужны для того, чтобы отправлять данные с веб-страницы на веб-сервер, который сможет эти данные обработать: зарегистрировать пользователя, создать сообщение на форуме, отправить письмо и так далее. В общем, формы в вебе просто необходимы.</p>
                    <p>Чтобы создать форму, нужно использовать парный тег &lt;form&gt;, внутри которого размещаются поля формы. У тега &lt;form&gt; есть два важных атрибута:

                        <ul class="list">
                            <li>action задаёт адрес, URL, отправки формы</li>
                            <li>method задаёт метод отправки формы</li>
                        </ul>
                    </p>
                    <p>Для отправки формы обычно используют методы get или post. Если не указать атрибут method, то будет использован get. Метод get посылает данные формы в строке запроса, то есть они видны в адресной строке браузера и следуют после знака вопроса. Метод get лучше использовать в поисковых формах, потому что он позволяет получить ссылку на результаты поиска и передать её кому-то.</p>
                    
                    <h3>Текстовое поле ввода</h3>
                    <p>Большинство полей форм создаётся с помощью одиночного тега &lt;input&gt;. У этого тега два обязательных атрибута:

                        <ul class="list">
                            <li>type задаёт тип поля</li>
                            <li>name задаёт имя поля</li>
                        </ul>
                    </p>
                    <p>Тип поля влияет на то, как оно будет отображаться и вести себя. Самый распространённый тип — это text, который обозначает текстовое поле. Он же используется по умолчанию. Имя поля нужно, чтобы правильно обработать данные на сервере. Обычно, имя поля должно быть уникальным в пределах формы, хотя есть исключения. Для задания имени поля используют латинские буквы и цифры.</p>
                
                    <h3>Идентификатор и значение по умолчанию</h3>
                    <p>Атрибут id поля ввода обозначает идентификатор. Он должен быть уникальным не только в пределах формы, но и на всей странице. Обычно идентификаторы используют для повышения удобства работы с формой, например, создают подписи, связанные с мелкими полями. При нажатии на такие подписи активируется связанное поле. И это удобно, так как по большой подписи попасть легче, чем по маленькому полю. Также идентификаторы используют в JavaScript для работы с полями. Идентификатор в отличие от имени поля не передаётся на сервер. Лучше использовать идентификаторы, отличающиеся от имени поля, особенно актуально это для полей множественного выбора, которые мы разберём далее в курсе. Атрибут value задаёт значение поля ввода по умолчанию. Это тоже повышает удобство.</p>
                
                    <h3>Подпись для поля ввода</h3>
                    <p>Есть специальный тег, который позволяет смело сказать: «Этот кусок текста действительно подпись к этому полю!». Это парный тег &lt;label&gt;. Он связывает текст и поле ввода логически. А ещё если нажать на текст в такой подписи, то курсор переместится в соответствующее поле. Создавать подписи к полям с помощью &lt;label&gt; — хороший приём. Используйте его. Первый способ создать подпись — просто обернуть текст подписи и тег поля в тег &lt;label&gt;&lt;/label&gt;. Надо отметить, что при оборачивании текста в тег &lt;label&gt; он визуально никак не меняется, ведь главная задача подписи — создать логическую связь.</p>
                    
                        <div class="form">
                            <form>
                                <label>
                                    Поле ввода
                                    <input type="text" name="field" id="field-id">
                                </label>
                            </form>
                        </div>

                    <h3>Связка подписи и поля по id</h3>
                    <p>Иногда обернуть поле и текст подписи в тег &lt;label&gt; нельзя. Например, когда они размещены в разных ячейках таблицы.</p>
                    <p>В этом случае можно связать подпись с полем с помощью атрибута id. Алгоритм такой:

                        <ol>
                            <li>Добавляем к полю ввода идентификатор с помощью атрибута id.</li>
                            <li>Оборачиваем текст подписи в тег &lt;label&gt;</li>
                            <li>Добавляем тегу &lt;label&gt; атрибут for.</li>
                            <li>В атрибут for записываем такое же значение, что и в атрибуте id у поля.</li>
                        </ol>
                    </p>
                
                        <div class="form">
                            <form>
                                <label for="out-of-range">Поле ввода</label>
                                <p>Filler text // Filler text Filler text // Filler text Filler text // Filler text </p>    
                                
                                <input type="text" name="field" id="out-of-range">
                            </form>
                        </div>   
                    
                    <h3>Поле для ввода пароля</h3>
                    <p>Одно из полей предназначено для ввода пароля, но сейчас оно является простым текстовым полем. Чтобы сделать его настоящим полем для ввода пароля, в котором текст будет отображаться «звёздочками», нужно просто изменить значение атрибута type на password.</p>

                        <div class="form">
                            <form>
                                <label for="password">Поле ввода</label>    
                                <input type="password" name="field" id="password">
                            </form>
                        </div>  
                    
                    <h3>Кнопка отправки формы</h3>
                    <p>Осталось добавить кнопку для отправки формы. Такая кнопка создаётся с помощью тега &lt;input&gt; c типом submit. Надпись на кнопке можно задать с помощью атрибута value. Для кнопки отправки формы задавать имя необязательно. Но если имя задано, то на сервер будут отправляться имя и значение кнопки. Обычно имя для кнопки отправки задают, когда в форме несколько кнопок, отвечающих за разные действия. Браузер отправляет на сервер имя и значение только той из них, на которую нажал пользователь. Таким образом, сервер может понять, какую кнопку нажали и что нужно сделать.</p>

                        <div class="form">
                            <form>
                                <label for="name-send">Поле ввода:</label>    
                                <input type="text" name="name-send" id="name-send">
                                <br>
                                <br>
                                <label for="pswrd-send">Поле пароля:</label>
                                <input type="password" name="pswrd-send" id="pswrd-send">
                                <br>
                                <br>
                                <input type="submit" value="Submit">
                            </form>
                        </div>  

                    <h3>Многострочное поле ввода</h3>
                    <p>Многострочное текстовое поле создаётся с помощью парного тега &lt;textarea&gt;. У него есть атрибуты name и id, которые аналогичны атрибутам текстового поля. Атрибут rows принимает целочисленное значение и задаёт высоту многострочного поля в строках. Атрибут cols задаёт ширину поля в символах. В качестве ширины символа берётся некоторая «усреднённая ширина». Атрибут value у многострочного поля отсутствует, а значение по умолчанию задаётся по-другому. Текст, расположенный между открывающим и закрывающим тегом &lt;textarea&gt; и является значением по умолчанию.</p>

                        <div class="form">
                            <form>
                                <textarea name="first-textarea" id="first-textarea" rows="10">Textarea</textarea>
                            </form>
                        </div>  

                    <h3>Чекбокс или «галочка»</h3>
                    <p>Поле-галочка — это тег &lt;input&gt; с типом checkbox. Галочка работает по принципу «либо да, либо нет». Если галочка стоит, то браузер посылает переменную с именем поля на сервер, если галочки нет, то не посылается ничего. Таким образом, атрибут value не является обязательным. Чтобы галочка стояла по умолчанию, нужно добавить к тегу атрибут checked. Чекбокс не подразумевает выбор одного элемента из нескольких. Поэтому если в одной форме есть несколько чекбоксов, то имена у них должны быть разными.</p>

                        <div class="form">
                            <form>
                                <input type="checkbox" name="first-check-one" id="first-check-one" checked>
                                <label for="first-check-one">Checkbox one</label>
                                <br>
                                <input type="checkbox" name="first-check-two" id="first-check-two">
                                <label for="first-check-two">Checkbox two</label>
                            </form>
                        </div>  

                    <h3>Переключатель или «радиобаттон»</h3>
                    <p>Поле-переключатель — это тег &lt;input&gt; с типом radio. Обычно переключатели размещают группами по несколько штук. Причём у переключателей из одной группы должно быть одинаковое имя и разные значения, которые задаются c помощью value. Таким образом, атрибут value является для переключателей обязательным. Браузер отправляет на сервер значение value выбранного переключателя.</p>

                    <h3>Группа переключателей</h3>
                    <p>Нужно добавить ещё один &lt;input&gt; с таким же именем, но другим значением value. Подобным образом можно создавать группы переключателей с любым количеством вариантов. Чтобы сделать какой-либо вариант в переключателе выбранным по умолчанию, нужно добавить к соответствующему тегу &lt;input&gt; атрибут checked, как у поля-галочки. Кстати, имя поля у переключателей одной группы должно быть одинаковым, но идентификаторы всегда должны быть уникальными.</p>
                        
                        <div class="form">
                            <form>
                                <label>
                                <input type="radio" name="question_one" value="one">
                                One
                                </label>
                                <br>
                                <label> 
                                <input type="radio" name="question_one" value="two">
                                Two
                                </label>    
                            </form>
                        </div>  

                    <h3>Раскрывающийся список или «селект»</h3>
                    <p>Раскрывающийся список так же, как и переключатель, позволяет выбрать один вариант ответа из нескольких. Раскрывающийся список создаётся с помощью парного тега &lt;select&gt;, у которого есть знакомые атрибуты name и id. Варианты ответов задаются с помощью парных тегов &lt;option&gt;, которые должны располагаться внутри тега &lt;select&gt;. В атрибуте value тега &lt;option&gt; задаётся значение варианта ответа, а внутри этого тега располагается подпись варианта ответа. Если при отправке формы у выбранного варианта задан value, то на сервер отправится значение этого атрибута. В противном случае будет отправлен текст подписи.</p>

                        <div class="form">
                            <form>
                                <select name="sel_preview">
                                    <option value="item1">Option 1</option>
                                    <option value="item2">Option 2</option>
                                    <option value="item3">Option 3</option>
                                </select>    
                            </form>
                        </div>  
                    
                    <h3>«Мультиселект»</h3>
                    <p>Раскрывающийся список можно превратить в так называемый «мультиселект», то есть список, в котором можно выбрать не один, а несколько вариантов. Чтобы сделать это, нужно добавить к тегу &lt;select&gt; атрибут multiple. Выбрать несколько вариантов можно, щёлкая по ним с зажатой клавишей Ctrl на Windows или Command на MacOS. Высоту мультиселекта можно изменять с помощью атрибута size тега &lt;select&gt;. Чтобы отметить как выбранные по умолчанию одно или несколько значений, нужно к соответствующим тегам &lt;option&gt; добавить атрибут selected. При отправке данных мультиселекта на сервер с PHP после имени в значении атрибута name ставятся символы квадратных скобок []. Например, &lt;select name="days[]"&gt;. Это необязательное требование для имени мультиселекта, а нужно только для корректной обработки данных в PHP.</p>

                        <div class="form">
                            <form>
                                <select name="sel_multi_preview" multiple size="6">
                                    <option value="item1" selected>Option 1</option>
                                    <option value="item2">Option 2</option>
                                    <option value="item3">Option 3</option>
                                    <option value="item4">Option 4</option>
                                    <option value="item5">Option 5</option>
                                    <option value="item6">Option 6</option>
                                </select>    
                            </form>
                        </div>  

                    <h3>Поле для загрузки файлов</h3>
                    <p>Поле для загрузки файлов — это тег &lt;input&gt; с типом file. Для этого поля обязательным атрибутом является имя. Чтобы поле заработало и браузер смог передать выбранный файл на сервер, необходимо добавить форме атрибут enctype со значением multipart/form-data. Не полю, а форме. Кстати, внешний вид таких полей очень сильно отличается в зависимости от операционной системы и очень плохо изменяется с помощью стилей.</p>

                        <div class="form">
                            <form enctype="multipart/form-data">
                                <input type="file" name="file_preview">      
                            </form>
                        </div>  

                    <h3>Скрытое поле</h3>
                    <p>И ещё одно невидимое и очень полезное поле. Это скрытое поле. Его используют, когда в форме нужно отправить какие-то дополнительные служебные данные, которые не вводятся пользователем. Например, это могут быть реквизиты заказа или номер пользователя в форме оплаты. Скрытое поле — это тег &lt;input&gt; с типом hidden.</p>

                        <div class="form">
                            <form>
                                <input type="hidden" name="hidden_preview">      
                            </form>
                        </div>   
                        
                    <h3>Сброс введенных значений</h3>
                    <p>В HTML-формах есть специальная кнопка, которая сбрасывает введённые значения и возвращает изначально установленные. Это поле ввода с типом reset. Кнопка не обнуляет значения, а возвращает те, которые были установлены в полях формы по умолчанию.</p>
                    <p>&lt;input type="reset" value="Сбросить"&gt;</p>

                    <h3>Простая кнопка</h3>
                    <p>Помимо кнопок отправки формы или сброса введенных значений, существуют и «просто кнопки». При нажатии на такую кнопку никаких действий не происходит, а все необходимые действия обычно задаются при помощи JavaScript.</p>
                    <p>&lt;input type="button" value="Кнопка"&gt;</p>

                    <h3>Кнопка-изображение</h3>
                    <p>В качестве кнопки отправки формы можно использовать изображение. Для этого у тега input нужно указать тип image. Аналогично обычным изображениям на сайте у кнопки-изображения есть еще два атрибута:

                        <ul>
                            <li>src	адрес изображения</li>
                            <li>alt	альтернативный текст, отображаемый в том случае, если изображение не загружено</li>
                        </ul>
                    </p>
                    <p>Кнопка-изображение работает аналогично кнопке submit, но на сервер дополнительно передаются координаты точки, по которой был произведен щелчок.</p>

                    <h3>Альтернативный способ задания кнопок</h3>
                    <p>Помимо тега <input> для добавления кнопок можно использовать тег &lt;button&gt;. Он расширяет возможности создания кнопок. Внутри тега &lt;button&gt; можно размещать любые HTML-элементы, в том числе изображения. Например:</p>
                    <p>&lt;button&gt;Календарь &lt;img src="calend.png" alt=""&gt;&lt;/button&gt;</p>
                    <p>Если в атрибуте type тега &lt;button&gt; указать значение submit или reset, то кнопка будет отправлять данные на сервер или сбрасывать введенные значения. По умолчанию значение атрибута type — submit. То есть внутри формы кнопка &lt;button&gt; по нажатию отправит форму на сервер. Значениями атрибута type также могут быть button и reset. Кнопка button со значением type="reset" аналогично input type="reset" сбрасывает значения полей формы к изначальным. А вот значение type="button" избавит кнопку от всей изначальной фунциональности. То есть кнопка просто будет выглядеть как кнопка, но ничего по умолчанию не делать. Это удобно, если вы хотите сами добавить кнопке дополнительное действие с помощью JavaScript.</p>

                    <h3>Обязательные поля</h3>
                    <p>Чтобы указать, что поле обязательно для заполнения, нужно добавить ему пустой атрибут required. При попытке отправить форму с незаполнеными обязательными полями браузер выведет всплывающее предупреждение. Эта проверка работает на клиентской части и упрощает валидацию форм. Но всегда нужно проверять отправленные данные и на стороне сервера.</p>
                    
                    <h3>Поле выбора даты</h3>
                    <p>Для выбора даты из календаря существует новый тип поля ввода — date. При клике на данное поле в форме всплывает календарик. type="date"</p>

                    <h3>Поле выбора времени</h3>
                    <p>Иногда нужно указывать дату в других форматах, и для этого существуют дополнительные «временные» типы полей, например, time для выбора времени. type="time"</p>

                    <h3>Список возможных значений</h3>
                    <p>Для текстовых полей можно заранее определить список возможных значений, которые отображаются, когда вы начинаете вводить текст в поле. Для этого существует специальный тег &lt;datalist&gt;.
                        <pre>
                            &lt;input type="text" list="browsers" name="browser"&gt;
                            &lt;datalist id="browsers"&gt;
                            &lt;option value="Firefox"&gt;&lt;/option&gt;
                            &lt;option value="Chrome"&gt;&lt;/option&gt;
                            &lt;option value="Safari"&gt;&lt;/option&gt;
                            &lt;/datalist&gt;
                        </pre>
                    </p>
                    <p>Связывание текстового поля и списка осуществляется при помощи атрибута list у тега input — значение list должно быть таким же, как значение атрибута id у списка.</p>

                    <h3>Поле ввода числового значения</h3>
                    <p>Для ввода числовых значений существует специальный тип поля ввода number. Рядом с полем браузер автоматически подставляет две стрелочки для увеличения и уменьшения числового значения type="number".</p>
                    <p>При помощи вспомогательных атрибутов min и max можно установить верхнюю и нижнюю границу допустимых значений. А атрибут step устанавливает величину шага изменения значения. Также стоит отметить, что поле ввода числа, как и некоторые другие поля, которые будут рассмотрены дальше, по-особому ведёт себя в мобильных браузерах: например, при фокусе на такое поле появляется клавиатура, позволяющая вводить соответствующие символы.</p>

                    <h3>Поле поиска</h3>
                    <p>type="search" - Это поле почти не отличается от обычного текстового поля. В некоторых браузерах внутри него появляется крестик для сброса введённого значения.</p>

                    <h3>Автофокус</h3>
                    <p>При загрузке страницы можно сообщить браузеру в какое поле установить курсор по умолчанию. Для этого используется пустой атрибут autofocus.</p>
                    <p>Автофокус улучшает процесс работы с формами, ведь пользователь избавляется от лишних щелчков мышки, там где они не нужны, а может сразу начинать вводить текст в поле. Обратите внимание, что такой атрибут должен быть только один на странице.</p>

                    <h3>Другие поля для ввода дат</h3>
                    <p>
                        
                        <ul>
                            <li>datetime - выбор даты с указанием времени (c учетом временной зоны)</li>
                            <li>datetime-local - выбор даты с указанием времени (без учета временной зоны)</li>
                            <li>week - выбор порядкового номера недели в году и года</li>
                            <li>month - выбор месяца и года</li>
                        </ul>
                    </p>

                    <h3>Выбор из диапазона</h3>
                    <p>Тип поля range выглядит как шкала с ползунком и позволяет выбрать число из некоторого интервала значений.Атрибуты min и max устанавливают нижнюю и верхнюю границу допустимых значений. А атрибут step устанавливает величину шага изменения значения.</p>
                        
                        <div class="form">
                            <form>
                                <input type="range" name="range_preview" min="1" max="10">      
                            </form>
                        </div>   

                    <h3>Область для вывода результата</h3>
                    <p>Тег &lt;output&gt; представляет собой область, куда выводятся какие-либо результаты вычислений, обычно полученные при помощи JavaScript.</p>
                    <p>&lt;output name="sum"&gt;[значение по умолчанию]&lt;/output&gt;</p>
                    <p>Значение по умолчанию при этом можно не задавать, тогда область вывода будет пустой.</p>

                    <h3>Группировка полей формы</h3>
                    <p>Когда формы становятся очень большими, возникает потребность зрительно отделить одни поля от других. Для группировки полей используется тег fieldset. По умолчанию браузеры отображают результат в виде рамки вокруг этой группы полей, но при помощи CSS можно изменить его внешний вид. Также для каждой группы можно добавить её заголовок. Для этого внутрь тега fieldset надо поместить тег legend:</p>

                        <div class="form">
                            <form>
                                <fieldset>
                                    <legend>Заголовок группы</legend>
                                    <input type="text">
                                    <input type="text">
                                    <input type="text">
                                </fieldset>
                                <fieldset>
                                    <textarea></textarea>
                                </fieldset>   
                            </form>
                        </div>  

                    <h3>Паттерны значений полей</h3>
                    <p>Чтобы добавить автоматическую проверку формата номера в поле, используем атрибут pattern, в котором с помощью регулярного выражения опишем требуемый формат.</p>

                        <div class="form">
                            <form>
                                <input type="text" pattern="[0-9]{4}-[0-9]{2}" placeholder="1234-12">   
                            </form>
                        </div>   

                    <h3>Поле ввода телефона</h3>
                    <p>Новый тип поля tel появился в HTML5 и отвечает за ввод телефонных номеров. Также воспользуемся атрибутом pattern, чтобы исключить ошибки при заполнении формы. В мобильных браузерах при фокусе на такое поле появляется клавиатура, позволяющая вводить только цифры и символы телефонных номеров.</p>

                        <div class="form">
                            <form>
                                <input type="tel" pattern="[0-9]{4}-[0-9]{2}" placeholder="1234-12">   
                            </form>
                        </div>   

                    <h3>Подсказка при заполнении полей</h3>
                    <p>У полей, в которые вводятся текстовые значения (textarea, разные типы input и так далее) есть возможность вывести подсказку. Для этого используется специальный атрибут placeholder:</p>

                        <div class="form">
                            <form>
                                <input type="text" placeholder="Подсказка">   
                            </form>
                        </div> 

                    <p>Текст подсказки выводится внутри текстового поля, а при вводе значения — автоматически убирается.</p>

                    <h3>Поля ввода адресов сайтов и email</h3>
                    <p>В HTML5 добавлены два типа полей email и url, предназначенные для ввода электронной почты и адреса сайта. Особенностью этих полей является то, что они автоматически проверяют формат введённых данных. Внешне эти поля не отличаются от обычных текстовых полей, но обладают важной особенностью, которая очень полезна на мобильных устройствах. Когда вы начинаете заполнять такое поле на мобильнике, там автоматически переключается раскладка клавиатуры. Например, для email отобразятся латинские символы, цифры, знак @ и некоторые другие.</p>

                        <div class="form">
                            <form>
                                <input type="email">
                                <input type="url">   
                            </form>
                        </div> 

                    <h3>Поле выбора цвета</h3>
                    <p>В HTML5 добавили новый тип color, предназначенный для полей выбора цвета. При клике на такое поле появляется окно с возможностью выбрать цвет из палитры.</p>

                        <div class="form">
                            <form>
                                <input type="color">   
                            </form>
                        </div> 

                    <h3>Группировка элементов списка</h3>
                    <p>Так как список выбора может быть довольно большой, в теге select используем возможность объединять option в группы. Обычно это используется для большей наглядности и удобства поиска нужного варианта. Для формирования группы используется тег optgroup. Атрибут label этого тега определяет заголовок группы.</p>

                        <div class="form">
                            <form>
                                <select name="variants">
                                    <optgroup label="Группа вариантов 1">
                                        <option value="1">Вариант 1</option>
                                        <option value="2">Вариант 2</option>
                                        <option value="3">Вариант 3</option>
                                    </optgroup>
                                    <optgroup label="Группа вариантов 2">
                                        <option value="4">Вариант 4</option>
                                        <option value="5">Вариант 5</option>
                                        <option value="6">Вариант 6</option>
                                    </optgroup>
                                </select>   
                            </form>
                        </div> 

                    <p>Вложенность групп не ограничена, внутрь каждой группы можно вложить другие группы. Аналогично можно группировать элементы и в списках со множественным выбором.</p>    

                    <h3>Запрет редактирования полей</h3>
                    <p>Иногда возникают ситуации, когда какие-то поля требуется сделать недоступными для редактирования. Есть два способа: использование атрибута readonly и использование атрибута disabled</p>

                        <div class="form">
                            <form>
                                <input type="text" readonly>
                                <input type="text" disabled>   
                            </form>
                        </div> 
                    
                    <p>В чем же отличие между ними?</p>
                    <p>Атрибут readonly не дает пользователю изменять поле (вводить новый текст, модифицировать существующий). Введенное значение можно выделить и скопировать. Данные из этого поля отправляются на сервер.</p>
                    <p>Атрибут disabled не дает пользователю изменять поле (вводить новый текст, модифицировать существующий). Нельзя поставить фокус в это поле, введенное значение нельзя выделять и копировать. Данные из этого поля НЕ отправляются на сервер.</p>

                    <h3>Управление автозаполнением полей</h3>
                    <p>Браузер может запоминать значения, вводимые в текстовые поля. При вводе первых букв текста выводится список сохранённых ранее значений, из которого можно выбрать подходящее. Параметрами автозаполнения можно управлять используя атрибут autocomplete. </p>
                    <p>Он может принимать два значения on и off. Первое включает автозаполнение, второе — отключает. Отключение автозаполнения обычно используется из соображений безопасности, например, чтобы не сохранялись пароли, номера банковских карт и так далее. Значение по умолчанию зависит от настроек браузера.</p>

                    <h3>Переключение между полями</h3>
                    <p>При нажатии клавиши Tab браузер передает управление (фокус) от одного элемента к другому в том порядке, в котором они были объявлены на странице. Этим порядком можно управлять при помощи атрибута tabindex.</p>

                            <div class="form">
                                <form>
                                    <input type="text" tabindex="1">
                                    <input type="text" tabindex="3">
                                    <input type="text" tabindex="2">   
                                </form>
                            </div> 

                    <p>В качестве значения может использоваться любое целое положительное число. Значения выстраиваются последовательно и переход между элементами происходит от меньшего значения к большему. Если представлено отрицательное значение — элемент может быть выделен, однако не учавствует в последовательной навигации. Если представлен 0 — элемент может быть выделен и достигнут с помощью последовательной навигации, однако порядок навигации определён платформой</p>

                    <h3>localStorage</h3>
                    <p>Можно использовать одну из новинок HTML5 — localStorage. Эта технология относится к JavaScript, а не к HTML или CSS</p>
                    <p>Суть localStorage или «локального хранилища» заключается в том, что в него можно записывать данные, которые будут сохраняться в браузере. Эти данные не исчезнут даже если вы закроете браузер и откроете его снова или уйдете со страницы и потом вернётесь на неё. Получается, что можно сохранять данные из формы в хранилище при работе с формой, а при загрузке страницы проверять хранилище на наличие данных, и если они есть, то подставлять их в форму. Таким образом можно предотвратить потерю данных при работе с формами.</p>

                    <h2>HTML 5</h2>
                    <h3>Теги header и footer</h3>
                    <p>Несколько важных фактов об HTML5:

                        <ul class="list">
                            <li>HTML5 обратно совместим с HTML4</li>
                            <li>HTML5 не цельная спецификация, а набор модулей разной степени готовности</li>
                            <li>Многие модули HTML5 имеют хорошую поддержку во всех текущих браузерах</li>
                            <li>HTML5 с нами надолго</li>
                       </ul>
                    
                    </p>
                    <p>Это означает, что HTML5 можно использовать уже сейчас. Для этого достаточно задать такой тип документа: &lt;!DOCTYPE html&gt;</p>
                    <p>А теперь пара новых тегов:
                        
                        <ul class="list">
                            <li>&lt;header&gt; — хедер сайта или раздела</li>
                            <li>&lt;footer&gt; — футер сайта или раздела</li>
                        </ul>
                    </p>
                    <p>Да-да, это те самые хедер и футер, которые обычно верстались дивами с классами header или footer. Они были настолько распространены, что для них было решено создать собственные теги.</p>

                    <h3>Основное содержание. Тег main</h3>
                    <p>Обратите внимание, что мы задали классы для хедера и футера. Сделано это потому, что этих элементов на странице может быть несколько. Хедер — это не только привычная шапка сайта с логотипом и меню, он может использоваться и как «шапка» какой-нибудь статьи или раздела сайта. Конечно, в случае со статьёй хедер называют не «шапкой», а вводной частью, в которой могут содержаться заголовки, оглавление и так далее.</p>
                    <p>С футером ситуация аналогичная. В привычном нам понимании это подвал сайта, с копирайтами, контактной информацией и так далее. Но футер может использоваться и в других разделах сайта. Например, в статье в футере можно разместить дополнительную информацию: данные об авторе, дополнительные ссылки и так далее.</p>
                    <p>А раз теги неуникальные, то и стилизовать их лучше с помощью классов, как мы и сделали. Если вы не хотите использовать классы для шапки и подвала сайта, то можете использовать селекторы body > header и body > footer. Эти селекторы не повлияют на хедеры и футеры, вложенные более глубоко.</p>
                    <p>Другое дело новый тег &lt;main&gt;, который обозначает основное содержание сайта и по спецификации может использоваться на странице только один раз. Для его стилизации никакие классы не нужны.</p>

                    <h3>Разделы страницы. Теги article и section</h3>
                    <p>Раньше почти все разделы верстались на дивах. Но в HTML5 добавили сразу два новых тега для разметки разделов:

                        <ul class="list">
                            <li>&lt;section&gt; — смысловой или логический раздел документа</li>
                            <li>&lt;article&gt; — самостоятельный и независимый раздел документа</li>
                        </ul>
                    </p>
                    <p>Чтобы не было путаницы, разберём где и когда использовать разные контейнеры

                        <ul class="list">
                            <li>&lt;div&gt; — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов</li>
                            <li>&lt;section&gt; — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.</li>
                            <li>&lt;article&gt; — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.</li>
                        </ul>
                    </p>

                    <h3>Изображения в формате SVG</h3>
                    <p>Для этого добавим в хедер &lt;div&gt;, а внутри него разместим привычное изображение. Используем картинку в векторном формате SVG, который уже достаточно хорошо поддерживается браузерами. Векторные изображения можно уменьшать и увеличивать без потери качества.</p>

                    <h3>Навигация. Тег nav</h3>
                    <p>В HTML5 добавили специальный элемент для навигационных блоков — тег &lt;nav&gt;. Так что теперь меню и блоки ссылок лучше оборачивать не в дивы, а в навы. В остальном же для меню ничего не изменилось. Это был список ссылок внутри дива, а стал список ссылок внутри нава.</p>

                    <h3>Использование нестандартных шрифтов</h3>
                    <p>В HTML5 появилась возможность подключать и использовать на странице любые нестандартные шрифты. Веб-шрифты поддерживаются большинством современных браузеров. Простейший способ использовать такой шрифт — найти его в специальном сервисе по названию, получить там код подключения шрифта, вставить этот код в свою вёрстку и использовать шрифт, как обычно, с помощью свойства font-family.</p>
                    <p>Подобных сервисов с бесплатными шрифтами достаточно много. Один из самых известных — это <a href="https://www.google.com/fonts">Google Fonts</a>. А вот похожий сервис: <a href="https://fontstorage.com/ru/">fontstorage</a>.</p>
                    <p>При использовании веб-шрифтов не забывайте указывать так называемые «фоллбэчные» шрифты — стандартные шрифты, которые будут отображаться, если веб-шрифт либо недоступен, либо не поддерживается старым браузером пользователя. Для этого нужно всего лишь перечислить их через запятую после нестандартного шрифта:
                        
                        <ul class="list">
                            <li>font-family: "PT Sans", "Arial", sans-serif;</li>
                        </ul>
                    </p>
                
                    <h3>Подробнее о шрифтах. Правило @font-face</h3>
                    <p>Технически подключение веб-шрифтов производится с помощью CSS-правила @font-face. Читается как «эт-правило font-face».</p>
                        <pre>
                         @font-face {
                             font-family: "Roboto";
                             src: local("Roboto Regular"),
                             url("roboto.woff") format("woff");
                         }
                        </pre>
                    <p>В этом правиле вы указываете название шрифта, которое будете использовать в font-family и источники, из которых браузер сможет загрузить шрифт. Обычно сначала указывают название шрифта в системе, чтобы браузер попытался найти его локально, а затем указывают адрес файла шрифта в интернете.</p>
                    <p>Получается, что можно хранить шрифты и подключать их со своего сервера. Это особенно полезно, когда шрифт очень редкий и его нет ни в одном из шрифтовых сервисов. В этом случае поступают так:

                        <ol>
                            <li>Берут файл шрифта (например, .ttf) и конвертируют в веб-формат в сервисе наподобие Font Squirrel (для кириллических шрифтов надо указать дополнительные параметры конвертации).</li>
                            <li>Затем сконвертированные файлы шрифта размещают у себя на сервере.</li>
                            <li>И подключают шрифт с помощью @font-face.</li>
                        </ol>
                    </p>
                     
                    <h3>Дополнительное содержание. Тег aside</h3>
                    <p>&lt;aside&gt; — это дополнительное содержание, не связанное напрямую с основным. Ещё такие блоки часто называют «сайдбарами» или боковыми панелями.</p>

                    <h3>Даты для людей и машин. Тег time</h3>
                    <p>В HTML5 добавили специальный тег для обозначения даты и времени — &lt;time&gt;. У этого тега есть атрибут datetime — для указания даты в машиночитаемом формате ISO 8601. С помощью &lt;time&gt; можно описывать даты одновременно и для человека, и для машины.</p>
                    <p>&lt;time datetime="2014-04-20"&gt;Вчера&lt;/time&gt; мы готовили курс к публикации.</p>
                    <p>Браузер отображает только содержимое тега, а содержимое datetime не отображается. Человек увидит только слово «вчера», а машина прочитает атрибут и получит дату в нужном ей формате.</p>

                    <h3>Картинки с подписями. Теги figure и figcaption</h3>
                    <p>Один из новых тегов — это &lt;figure&gt;. Вспомните в книжках или учебниках изображения-выноски с подписями. Вот это и есть аналог &lt;figure&gt;. Цельный и независимый блок содержания. Внутри этого тега размещают демонстрационный материал: изображения, схемы, куски кода и так далее. Обычно каждый такой материал сопровождает разъясняющий комментарий или «легенда». Для обозначения этого комментария и предназначен ещё один новый тег — &lt;figcaption&gt;, который размещается первым или последним элементом внутри &lt;figure&gt;</p>

                        <figure>
                            content
                            <figcaption>Caption</figcaption>
                        </figure>

                    <h3>Видео. Тег video</h3>
                    <p>В HTML с самого начала было очень просто вставлять изображения, но очень сложно видео и аудио. В HTML5 эту проблему попытались решить, добавив специальные теги. Для вставки видео предназначен тег &lt;video&gt;. Его основные атрибуты:

                        <ul class="list">
                            <li>width и height - задают ширину и высоту видео</li>
                            <li>controls - пустой атрибут, при наличии которого отображается панель управления видео</li>
                            <li>preload	- задаёт режим предзагрузки видео, имеет 3 возможных значения: 
                                <ul class="list">
                                    <li>none — не загружать ничего</li>
                                    <li>metadata — загрузить служебную мета-информацию (длительность, первый кадр и так далее)</li>
                                    <li>auto — можно загрузить всё видео</li>
                                    <li>значение по умолчанию зависит от браузера</li>
                                </ul>
                            </li>
                            <li>src	- задаёт адрес видеофайла</li>
                            <li>autoplay - пустой атрибут, при наличии которого воспроизведение видео начинается автоматически</li>
                            <li>poster - задаёт адрес картинки-обложки, которая отображается, когда видео ещё не загрузилось или не воспроизводится</li>
                        </ul>
                    </p>

                    <h3>Форматы и источники видео</h3>
                    <p>У тега &lt;video&gt; есть атрибут src, в котором можно указать адрес видеофайла. В текущий момент существует несколько форматов видео, каждый из которых хорошо поддерживается лишь некоторыми браузерами. Вот три самых распространённых формата и их поддержка:

                        <ul class="list">
                            <li><a href="caniuse.com/mpeg4">MPEG-4/H.264</a></li>
                            <li><a href="caniuse.com/ogv">OGG/Theora</a></li>
                            <li><a href="caniuse.com/webm">WebM</a></li>
                        </ul>
                    </p>
                    <p>Поэтому мы должны в видео указывать адреса файлов во всех этих форматах (и конвертировать исходное видео в эти форматы, конечно). Делается это с помощью тегов &lt;source&gt;:

                       <pre>
                            &lt;video controls&gt;
                            &lt;source src="video.mp4" type="video/mp4"&gt;
                            &lt;source src="video.ogv" type="video/ogg"&gt;
                            &lt;source src="video.webm" type="video/webm"&gt;
                            &lt;/video&gt;
                       </pre>
                    </p>
                    <p>В атрибуте src указывается адрес видеофайла, а в атрибуте type его тип (также там могут указываться и кодеки). Браузер из списка видеофайлов выбирает первый, который может проиграть и загружает его. Атрибут type не является обязательным, так как браузер умеет сам определять тип и кодеки, но указывая тип явно, мы помогаем ему не ошибиться.</p>

                    <h3>Аудио. Тег audio</h3>
                    <p>Работа с аудио в HTML5 очень похожа на работу с видео, только у тега для аудио чуть меньше параметров. Для вставки звука предназначен тег &lt;audio&gt;. Его основные атрибуты:

                        <ul class="list">
                            <li>controls - пустой атрибут, при наличии которого отображается панель управления проигрывателем</li>
                            <li>preload	- задаёт режим предзагрузки аудио, имеет 3 возможных значения:
                                <ul>
                                    <li>none — не загружать ничего</li>
                                    <li>metadata — загрузить служебную мета-информацию</li>
                                    <li>auto — можно загрузить весь файл</li>
                                </ul>
                            </li>
                            <li>значение по умолчанию зависит от браузера</li>
                            <li>src	- задаёт адрес аудиофайла</li>
                            <li>autoplay - пустой атрибут, при наличии которого воспроизведение звука начинается автоматически</li>
                        </ul>
                    </p>

                    <h3>Форматы и источники звука</h3>
                    <p>У звуковых файлов с поддержкой форматов дела обстоят лучше, чем у видео. Для охвата большинства современных браузеров, достаточно использовать всего два формата:

                        <ul>
                            <li>MP3</li>
                            <li>OGG</li>
                        </ul>
                    </p>
                    <p>И снова мы не можем указать только один файл в атрибуте src у тега audio. Мы должны так же, как и в случае с видео, перечислить адреса звуковых файлов в разных форматах с помощью тегов source:
                        <pre>
                            &lt;audio controls&gt;
                                &lt;source src="sound.mp3" type="audio/mpeg"&gt;
                                &lt;source src="sound.oga" type="audio/ogg"&gt;
                            &lt;/audio&gt;
                        </pre>
                    </p>
                    


                </article>
                    
                <article>
                    <h2>Атрибуты</h2>
                    <p>class=" " - задание идентификатора по классу (больше одного на странице)</p>
                </article>
                </section>

            <section>
                <header class="title">    
                    <h1>CSS</h1>
                </header>

                <article>
                    <h2>Введение в CSS</h2>
                    <p>CSS расшифровывается как «каскадные таблицы стилей». Этот язык отвечает за внешний вид HTML-страницы. Синтаксис языка достаточно прост: он состоит из селекторов и свойств. С помощью селекторов можно сказать браузеру какие именно элементы мы хотим оформить. Свойства описывают как именно мы хотим оформить эти элементы. То есть селекторы — это снайперский прицел, а свойства — это кисть, рубанок, скальпель и перфоратор.</p>
                    
                    <h2>CSS-правила</h2>
                    <p>Весь CSS-код состоит из повторяющихся блоков следующего вида:
                        
                        <pre>
                            selector {
                                property: value;
                                property: value;
                            }
                        </pre>
                    </p>
                    <p>Такой блок называется «CSS-правило». Каждое CSS-правило содержит хотя бы один селектор и свойство. Простейшие селекторы — это селекторы по именам тегов. С их помощью можно задать стили для всех абзацев на странице, для всех ссылок, заголовков первого уровня и так далее. Такие селекторы содержат имя тега без символов < и >.</p>
                    
                    <h2>Продвинутые селекторы</h2>
                    <p>К более сложным селекторам можно отнести селекторы с использованием классов и псевдоклассов. Класс позволяет объединять разные элементы в смысловые группы и применять к ним одинаковое оформление. Например, можно создать класс «элементы с ошибкой» и задать ему красный цвет текста. Затем можно добавлять этот класс к любому HTML-тегу: абзацу, заголовку, элементу списка и так далее. Класс тега можно задать с помощью атрибута class, который содержит имя класса (или имена классов через пробел)

                        <ul>
                            <li>&lt;p class="help"&gt;</li>
                            <li>&lt;p class="help error"&gt;</li>
                        </ul>
                    </p>
                    <p>В примере у первого абзаца задан класс help, у второго абзаца заданы классы help и error. Селектор с использованием класса задаётся так: .имя_класса.

                        <ul>
                            <li>.help { ... }</li>
                            <li>.error { ... }</li>
                        </ul>
                    </p>

                    <h2>Свойства для оформления текста</h2>
                    <p>В CSS существует огромное количество свойств. Их можно разбить на следующие группы:

                        <ul>
                            <li>оформление текста</li>
                            <li>работа с размерами и отступами</li>
                            <li>позиционирование элементов</li>
                            <li>создание сеток</li>
                            <li>декоративные: цвета, фон, тени</li>
                            <li>другие</li>
                        </ul>
                    </p>

                    <h2>Свойства для задания размеров и отступов</h2>
                    <p>С помощью CSS можно задавать ширину, высоту, внешние и внутренние отступы элементов, минимальную и максимальную ширину и высоту и так далее.</p>
                    <p>Все свойства, которые так или иначе влияют на размеры и отступы элементов, описываются в так называемой «Блочной модели документа». Помимо свойств для отступов и размеров в блочную модель входят свойства для описания границ и очень важное свойство display, которое определяет тип элемента (блочный, строчный и другие).</p>

                    <h2>Позиционирование элементов</h2>
                    <p>С помощью позиционирования можно очень точно и гибко управлять расположением элементов. Позиционирование применяют для создания сложных «многослойных» интерфейсов, таких как всплывающие окна или галереи, а также для вёрстки мелких декоративных элементов.</p>
                    <p>Главным свойством для работы с позиционированием является position, которое переключает режимы позиционирования элемента. Ещё четыре свойства: top, right, bottom, left, управляют расположением элемента. И последнее свойство z-index управляет порядком слоёв.</p>

                    <h2>Создание сетки страницы</h2>
                    <p>Типичный веб-сайт состоит из шапки, главного меню, блока с основным содержанием, боковых колонок, подвала. Эти блоки могут быть расположены друг под другом, в несколько колонок или ещё сложнее. Такое взаимное расположение основных блоков сайта и называют «сеткой» или «раскладкой». Сетка может быть фиксированной или тянущейся, когда ширина блоков изменяется в зависимости от ширины браузера. Чтобы быстро и легко создавать сетки, нужно хорошо разбираться в блочной модели и позиционировании.</p>

                    <h2>Декоративные свойства</h2>
                    <p>Чтобы сделать страницу яркой и красивой можно использовать множество свойств: цвет текста, фон, тени, рамки, закругления и многие другие.</p>

                    <h2>Каскадность</h2>
                    <p>Напомним, что CSS расшифровывается как «каскадные таблицы стилей». Почему именно каскадные? Всё дело в том, что стили для элемента могут быть определены в нескольких местах: внутри одного файла стилей и в разных файлах стилей. Браузер находит все CSS-правила, затрагивающие данный элемент, а затем комбинирует их и получает итоговый список свойств для этого элемента. Комбинирование свойств производится по чётким правилам, которые опираются на приоритетность и специфичность. Название «каскадные» появилось из-за описанного механизма комбинирования стилей из разных CSS-правил.</p>

                    <h2>Каскадность и приоритеты</h2>
                    <p>Когда для одного и того же элемента есть несколько CSS-правил с одинаковыми свойствами, браузер использует понятия приоритетов и специфичности, чтобы выбрать значение свойства из нескольких возможных. Упрощённо, можно сказать что:

                        <ol>
                            <li>CSS-правила в значении атрибута style самые приоритетные</li>
                            <li>за ними идёт селектор с id</li>
                            <li>затем селектор с классом</li>
                            <li>затем селектор с именем тега</li>
                        </ol>
                    </p>

                    <h2>Наследование</h2>
                    <p>Другой важный механизм CSS — это наследование. Он заключается в том, что часть стилей может передаваться от родительского элемента к дочерним (вложенным в него). Например, все элементы внутри тега body являются дочерними по отношению к нему. Если для body в стилях задать цвет текста красным, то цвет всех остальных элементов тоже станет красным. Ещё пример: тег ul является родительским по отношению к вложенным в него тегам li. Если задать для ul шрифт курсивом, то и внутри всех li шрифт станет курсивным.</p>

                    <h2>Ненаследуемые свойства</h2>
                    <p>Наследование работает не для всех свойств. Некоторые свойства применяются только к самому элементу и не переходят к его потомкам. К таким ненаследуемым свойствам относятся: ширина, высота, отступы, режим позиционирования и другие. Согласитесь, было бы странно задать отступы для body и обнаружить, что у всех вложенных элементов тоже появились отступы.</p>

                    <h2>Селекторы</h2>

                    <h3>Нелёгкая жизнь без селекторов</h3>
                    <p>Селекторы позволяют очень точно указывать к каким элементам применять CSS-свойства. Задавать атрибут style для каждого тега неудобно и долго. Особенно, если тот же результат можно получить с помощью единственного CSS-правила, в котором используется селектор для тега. С помощью селекторов по именам тегов можно задать стили для всех элементов списка, изображений, абзацев и так далее. Эти селекторы содержат имя тега без символов < и ></p>
                    <p>li { ... }</p>

                    <h3>Селекторы по классам</h3>
                    <p>Класс — это один из атрибутов тегов. Выглядит он вот так: &lt;li class="first"&gt;</p>
                    <p>Этот атрибут особенный, так как в CSS существует возможность выбирать элементы по классу. Делается это с помощью такого селектора: .имя_класса. Имена классов могут состоять из латинских символов, цифр и знаков - и _. Имя класса должно начинаться с латинской буквы.</p>

                    <h3>Контекстные селекторы</h3>
                    <p>Селектор может состоять из нескольких частей, разделённых пробелом. Такие селекторы называют контекстными или вложенными. Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент. Например, селектор .menu a сработает для ссылки a только в том случае, если она расположена внутри элемента с классом .menu. Читать их проще всего справа налево. Таким образом, можно задавать элементам различные стили в зависимости от их контекста. Если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет.</p>

                    <h3>Соседние селекторы</h3>
                    <p>Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом. Например, теги &lt;li&gt; в списке являются соседними по отношению друг к другу и вложенными в тег &lt;ul&gt;. Соседние селекторы записываются с помощью знака +, например, селектор1 + селектор2. Стили применятся к элементу, подходящему под селектор2, только если сразу перед ним расположен элемент, подходящий под селектор1. Селектор .hit + .miss применит стили к элементу с классом miss, так как перед ним есть элемент с классом hit. Селектор .hit + li тоже применит стили к элементу с классом miss, а селектор .miss + .hit не сработает.</p>

                    <h3>Контекстные и соседние селекторы</h3>
                    <p>Селекторы в CSS можно очень гибко комбинировать. В частности, можно комбинировать контекстные и соседние селекторы. Например, селектор .player-1 .hit + .miss сработает для тега с классом miss, если сразу перед ним расположен тег с классом hit и оба тега расположены внутри тега с классом player-1.</p>

                    <h3>Дочерние селекторы</h3>
                    <p>Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки.

                        <ul>
                            <li>Родитель
                                <ul>
                                    <li>дочерний (потомок)</li>
                                    <li>дочерний</li>
                                </ul>
                            </li>
                            <li>/родитель</li>
                        </ul>
                    </p>
                    <p>По отношению к &lt;ul&gt; &lt;li&gt; являются дочерними элементами и потомками, а &lt;span&gt; — потомки, но не дочерние элементы. Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Особенно это полезно при работе с многоуровневыми списками.</p>
                    <p>Для этого существует дочерний селектор, в котором используется символ >. Например: ul > li или ul > li > span.</p>

                    <h3>Псевдоклассы</h3>
                    <p>Псевдоклассы — это дополнения к обычным селекторам, которые делают их ещё точнее и мощнее. Обычный селектор — это снайперский прицел, а с псевдоклассом он становится прибором ночного видения. Псевдокласс добавляется к селектору c помощью символа :, вот так селектор:псевдокласс. Знакомство с псевдоклассами мы начнём с first-child и last-child. Псевдокласс first-child позволяет выбрать первый дочерний элемент родителя, а last-child — последний дочерний элемент.</p>

                    <h3>Псевдокласс :nth-child</h3>
                    <p>С помощью псевдокласса nth-child можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: селектор:nth-child(выражение). Выражением может быть число или формула.</p>

                    <h3>:nth-child и контекстные селекторы</h3>
                    <p>Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.</p>
                    <p>.shooter-2 li:nth-child(3) { ... }</p>
                    <p>Выберет третий тег li внутри блока с классом shooter-2.</p>

                    <h3>Псевдокласс :hover</h3>
                    <p>Некоторые псевдоклассы позволяют выбирать элементы, с которыми взаимодействует пользователь. Сначала познакомимся с псевдоклассом :hover. Этот псевдокласс позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата.

                        <ol>
                            <li>a:hover { ... }</li>
                            <li>tr:hover { ... }</li>
                            <li>.menu-item:hover { ... }</li>
                        </ol>
                    </p>
                    <p>Первый селектор выбирает ссылку, второй строку таблицы, третий элемент с классом menu-item, но только в том случае, если на них наведён курсор мыши. Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и интерактивность, так как элементы начинают реагировать на действия пользователя, изменяя свой внешний вид.</p>

                    <h3>Динамические эффекты с помощью :hover</h3>
                    <p>Львиная доля динамических эффектов, создаваемых с помощью CSS, опираются на несколько псевдоклассов, главный из которых, конечно же, :hover. Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов.
                        <pre>
                            li.top ul.submenu {
                                display: none;
                            }
                              
                            li.top:hover ul.submenu {
                                display: block;
                            }
                        </pre>
                    </p>
                    <p>Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, наведут курсор, то надо показать подменю». Вот так всё просто. Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. То есть всё работает на контекстных селекторах вида селектор1:hover селектор2.</p>

                    <h3>Псевдоклассы :link, :visited и :active</h3>
                    <p>Познакомимся с псевдоклассами для ссылок:

                        <ul>
                            <li>:link выбирает ещё не посещённые ссылки</li>
                            <li>:visited выбирает посещённые ссылки</li>
                            <li>:active выбирает активные ссылки (кнопка мыши зажата на ссылке)</li>
                        </ul>
                    
                        Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.
                    </p>

                    <h3>Псевдокласс :focus</h3>
                    <p>Псевдокласс :focus позволяет выбрать элемент, который в данный момент в фокусе. Например, текстовое поле, в которое установлен курсор, находится в фокусе. В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши tab, то в фокус будут попадать ссылки.</p>

                    <h3>Селекторы атрибутов</h3>
                    <p>Ранее мы познакомились с атрибутом class и специальными селекторами по классу. Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам. Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями. Селекторы атрибутов записываются с использованием квадратных скобок: элемент[атрибут]. Примеры селекторов:

                        <ol>
                            <li>input[checked] { ... }</li>
                            <li>input[type="text"] { ... }</li>
                        </ol>
                    
                        Первый селектор выберет поля формы, у которых есть атрибут checked, второй селектор выберет поля формы, у которых атрибут type имеет значение text.
                    </p>                    

                    <h3>Селектор по id</h3>
                    <p>Существует ещё один HTML-атрибут, для которого существует специальный селектор. Этот атрибут id (идентификатор), а селектор записывается с помощью символа #, например, #some-id. На значение id распространяются те же ограничения, что и на имя класса. Также id должен быть уникальным на странице.</p>
                    <p>Использование селекторов по id при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.</p>

                    <h2>Наследование и каскадирование</h2>
                    <h3>Иерархическое дерево</h3>
                    <p>HTML-документ представляет собой иерархическое дерево. Это означает, что у каждого элемента (кроме корневого) есть только один родитель, т.е. элемент, внутри которого он располагается. У корневого раздела родитель отсутствует. Рассмотрим простейшую страницу:
                        <pre>
                            &lt;html&gt;
                                &lt;head&gt;&lt;/head&gt;
                                    &lt;body&gt;
                                        &lt;p&gt;Текст документа&lt;/p&gt;
                                        &lt;p class="text"&gt;Выделенная &lt;span&gt;строка&lt;/span&gt;&lt;/p&gt;
                                    &lt;/body&gt;
                            &lt;/html&gt; 
                        </pre>
                    </p>
                    <p>Для этой страницы можно нарисовать такое иерархическое дерево: <img src="1.png"></p>
                    <p>Оно схематически отображает структуру вложенности элементов. В данном примере видно, что у элемента span родителем является p.text, а у p.text родитель — body. Иерархическая структура документа определяет основы концепции наследования.</p>

                    <h3>Наследование</h3>
                    <p>Наследование в CSS — механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам. Стили, присвоенные некоторому элементу, наследуются всеми потомками (вложенными элементами), если они не переопределены явно. Например, размер шрифта и его цвет достаточно применить к body, чтобы все элементы внутри имели те же свойства. Наследование позволяет сократить размер таблицы стилей, но если стилей много, то отследить какой родительский элемент установил некоторое свойство, становится сложнее.</p>

                    <h3>Наследование «на пальцах»</h3>
                    <p>Давайте на простых примерах подробнее разберёмся, в чём же преимущество наследования. Рассмотрим пример:</p>
                    <p>&lt;p class="text"&gt;Cтрока c выделенным &lt;span&gt;словом&lt;/span&gt;&lt;/p&gt;</p>
                    <p>Представим, что нам нужно установить красный цвет текста для всего текста. Зададим CSS-свойства следующим образом:
                        <pre>
                            .text {
                                color: red;
                              }  
                        </pre>
                    </p>
                    <p>Благодаря наследованию цвет текста в теге span автоматически станет красным. Если бы наследование не работало, нам пришлось бы отдельно прописывать цвет текста для тега span. И тогда установка таких простых свойств как стиль шрифта стала бы большой проблемой: нужно было бы задавать свойства для всех возможных вложенных тегов.</p>

                    <h3>Ещё немного про наследование</h3>
                    <p>Наверняка вы обращали внимание, что не все свойства наследуются тегами-потомками от их родителей. Действительно, было бы странно, если бы свойство border автоматически устанавливалось для всех вложенных элементов.</p>
                    <p>&lt;p class="bordered"&gt;Cтрока c выделенным &lt;span&gt;словом&lt;/span&gt;&lt;/p&gt;</p>
                    <p>Установим CSS-свойство:
                        <pre>
                            .bordered {
                                border: 1px solid green;
                              }
                        </pre>
                    </p>
                    <p>Граница будет нарисована только у тега p.</p>

                    <h3>Наследуемые свойства</h3>
                    <p>К наследуемым свойствам относятся в первую очередь свойства, определяющие параметры отображения текста:</p>
                    <p>font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и т. д.</p>
                    <p>Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно реже.</p>
                    <p>Весь список наследуемых свойств смотрите в <a href="https://www.w3.org/TR/CSS21/propidx.html">стандарте CSS</a>. Значение yes в колонке Inherited?.</p>
                    <p>Эти свойства можно и нужно задавать через предков, следуя семантике документа. Например, параметры текста зачастую не меняются в пределах отдельных блоков страницы: меню, основного содержания, информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях самих блоков.</p>

                    <h3>Ненаследуемые свойства</h3>
                    <p>Относятся к ненаследуемым это параметры позиционирования, размеров, отступов, фона, рамок и т. д.</p>
                    <p>А именно: background, border, padding, margin, width, height, position и др.</p>
                    <p>Весь список ненаследуемых свойств смотрите в <a href="https://www.w3.org/TR/CSS21/propidx.html">стандарте CSS</a>. Значение no в колонке Inherited?.</p>
                    <p>Не наследуются они из соображений здравого смысла. Например: если для какого-либо блока установлен внутренний отступ, автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.</p>

                    <h3>Принудительное наследование</h3>
                    <p>Для каждого свойства может быть задано значение inherit. Оно означает, что данное свойство принимает такое же значение, как и у родительского элемента. Значение inherit может быть использовано для усиления наследуемых значений, а также в свойствах, которые обычно не наследуются. Запись выглядит следующим образом:
                        <pre>
                            p {
                                background: inherit;
                              }
                        </pre>
                    </p>
                    <p>В данном случае у тегов p свойство background будет таким же, как и у их родительских тегов.</p>

                    <h3>Каскадирование</h3>
                    <p>CSS расшифровывается как «Cascading Style Sheets» или «каскадные таблицы стилей». Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил (наборов CSS-свойств). Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, каким будет финальный набор свойств элемента. Например, для элемента:</p>
                    <p>&lt;p class="text" style="color: red;"&gt;&lt;/p&gt;</p>
                    <p>CSS-правила существуют как минимум в трёх разных местах:
                        
                        <ol>
                            <li>в подключаемом файле style.css для селекторов p или .text;</li>
                            <li>в атрибуте style;</li>
                            <li>в стандартных стилях отображения, встроенных в браузер.</li>
                        </ol>
                    </p>
                    <p>Каскадирование как раз и определяет, какие именно свойства из этих источников применятся к данному абзацу. Имеется три основные концепции, управляющие порядком, в котором применяются CSS-свойства:

                        <ol>
                            <li>важность</li>
                            <li>специфичность</li>
                            <li>порядок исходного кода</li>
                        </ol>
                    </p>
                    <p>Перед тем как разбирать сложные правила работы каскадирования, расчёта специфичности и определения приоритетов, потренируемся на котиках. Разберём пример. Вот HTML-код, в котором есть абзац с двумя классами:</p>
                    <p>&lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt;</p>
                    <p>А вот CSS-код c двумя правилами для этих классов:
                        <pre>
                            .blue {
                                color: blue;
                              }
                              
                              .red {
                                color: red;
                              }
                        </pre>
                    </p>
                    <p>Вопрос: какого цвета будет текст абзаца? Какое из CSS-правил приоритетнее? Ответ: красного цвета, второе правило приоритетнее. Это происходит потому, что селекторы у правил одинакового типа, и соответственно обладают одинаковой специфичностью. В таком случае более высоким приоритетом обладает то правило, которое расположено в CSS-коде ниже. В нашем случае это правило для класса red.</p>
                    <p>Чуть более сложный пример. Тот же HTML:</p>
                    <p>&lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt;</p>
                    <p>Немного другой CSS:
                        <pre>
                            .blue {
                                color: blue;
                              }
                              
                              .red {
                                color: red;
                              }
                        </pre>
                    </p>
                    <p>В этом случае текст абзаца будет синим. Происходит это потому, что селектор p.blue более специфичный, чем селектор .red. Простое объяснение специфичности звучит так: Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее. В нашем примере селектор .red выберет все теги с нужным классом, а селектор p.blue выберет только абзацы с нужным классом.</p>
                    <p>А теперь посмотрим, как ведут себя контекстные селекторы.
                        <pre>
                            &lt;div class="experiment"&gt;&lt;/div&gt;
                                &lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt;
                            &lt;/div&gt;
                        </pre>
                    </p>
                    <p>И в CSS используем контекстный селектор для второго правила:
                        <pre>
                            p.blue {
                                color: blue;
                              }
                              
                              .experiment .red {
                                color: red;
                              }
                        </pre>
                    </p>
                    <p>Как вы уже знаете, существуют селекторы не только по классам, но и по id. Они начинаются с решётки #. HTML:
                        <pre>
                            &lt;div id="experiment-1" class="experiment"&gt;
                            &lt;p class="red blue"&gt;Синий или красный?&lt;/p&gt;
                            &lt;/div&gt;
                        </pre>
                    </p>
                    <p>CSS:
                        <pre>
                            #experiment-1 .blue {
                                color: blue;
                              }
                              .experiment .red {
                                color: red;
                              }
                        </pre>
                    </p>
                    <p>Особенность атрибута id заключается в том, что его значение должно быть уникальным в пределах страницы. То есть, может существовать только один тег с определенным значением id. Получается, что селектор по id может выбрать только один элемент. И поэтому он на порядок специфичнее селекторов по тегам, классам, а также комбинаций этих селекторов.</p>
                    <p>CSS-правила, которые прописаны в style обладают наивысшим приоритетом. Такой способ задания стилей не приветствуется в профессиональной вёрстке сайтов и годится только для создания быстрых прототипов. Поэтому мы и назвали этот приём запрещённым. Однако существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте style. Для этого нужно использовать ключевое слово !important. Оно задаёт CSS-свойству усиленный приоритет. Вот пример:</p>
                    <p>HTML: &lt;p style="color: red;" class="blue"&gt;Синий или красный?&lt;/p&gt;
                    </p>
                    <p>
                        CSS:
                        <pre>
                            .blue {
                                color: blue !important;
                              }
                        </pre>
                    </p>
                    <p>Цвет текста в этом примере будет синим. При вёрстке не рекомендуется часто использовать !important. По возможности старайтесь обходиться без него.</p>
                    <p>Как вы уже догадались, самым главным механизмом для определения приоритетов стилей является специфичность. Поэтому давайте еще немного потренируемся работать с ней. Рассмотрим пример: на полу в коробке сидит кот
                        <pre>
                            &lt;div id="floor"&gt;
                            &lt;span class="cat-in-box"&gt;Кексик&lt;/span&gt;
                            &lt;/div&gt;
                        </pre>
                    </p>
                    <p>Допустим в стилях существуют следующие определения:
                        <pre>
                            span {
                                background-color: #27ae60; /* Зелёный */
                              }
                              
                              div span {
                                background-color: #2980b9; /* Синий */
                              }
                              
                              #floor .cat-in-box {
                                background-color: #34495e; /* Мокрый асфальт */
                              }
                              
                              .cat-in-box {
                                background-color: #8e44ad; /* Фиолетовый */
                              }
                              
                              #floor span {
                                background-color: #c0392b; /* Красный */
                              }
                              
                              div .cat-in-box {
                                background-color: #e67e22; /* Оранжевый */
                              } 
                        </pre>
                    </p>
                    <p>А теперь вопрос на засыпку: какого цвета будет коробка? Сначала сделайте предположение, а затем проверьте.</p>

                    <h3>Расчёт значения специфичности</h3>
                    <p>Специфичность селектора разбивается на 4 группы — a, b, c, d:

                        <ul>
                            <li>если стиль встроенный, т.е. определен как style="...", то а=1, иначе a=0</li>
                            <li>значение b равно количеству идентификаторов (тех, которые начинаются с #) в селекторе</li>
                            <li>значение c равно количеству классов, псевдоклассов и селекторов атрибутов</li>
                            <li>значение d равно количеству селекторов типов элементов и псевдо-элементов</li>
                        </ul>
                    </p>
                    <p>После этого полученное значение приводится к числу (обычно в десятичной системе счисления). Селектор, обладающий большим значением специфичности, обладает и большим приоритетом.</p>
                    <div class="table">
                        <table>
                            <tr>
                                <th>Селектор</th>
                                <th>a, b, c, d</th>
                                <th>Число</th>
                            </tr>
                            <tr>
                                <td>span</td>
                                <td>0, 0, 0, 1</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <td>div .cat-in-box</td>
                                <td>0, 0, 1, 1</td>
                                <td>11</td>
                            </tr>
                            <tr>
                                <td>#floor .cat-in-box</td>
                                <td>0, 1, 1, 0</td>
                                <td>110</td>
                            </tr>
                            <tr>
                                <td>div span</td>
                                <td>0, 0, 0, 2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>.cat-in-box</td>
                                <td>0, 0, 1, 0</td>
                                <td>10</td>
                            </tr>
                            <tr>
                                <td>#floor span</td>
                                <td>0, 1, 0, 1</td>
                                <td>101</td>
                            </tr>
                        </table>
                    </div>

                    <h3>Перекрестное наследование</h3>
                    <p>При создании стилей для сходных по внешнему виду или функциональности элементов, которые могут использоваться на странице неоднократно, очень удобно пользоваться перекрёстным наследованием. Приём этот заключается в следующем:
                        
                        <ol>
                            <li>создается базовый стиль для таких элементов</li>
                            <li>определяются вспомогательные стили, которые применяются к элементам по мере надобности</li>
                            <li>элемент наследует базовый стиль и один или несколько вспомогательных.</li>
                        </ol>
                    </p>
                    
                    <h4>Пример:</h4>
                    <p>На странице используются кнопки разного назначения: для отправки форм, для сброса информации в полях формы, как элементы навигации и т.д. Можно вынести общее оформление (размеры, отступы и т.д.) для всех кнопок в отдельное CSS-правило для класса, например, .button. А затем создать дополнительные CSS-правила, в которых будут определены только различающиеся свойства этих кнопок, например, цвет фона. Для этих правил можно использовать такие названия классов: .button-send, .button-clear, .button-navigation. Каждая кнопка в HTML-коде будет иметь два класса: общий и дополнительный.</p>

                    <h3>Объединение селекторов</h3>
                    <p>Иногда может потребоваться выбрать элементы, которые одновременно удовлетворяют сразу нескольким условиям. В CSS есть запись, которая фактически выполняет операцию логического умножения, «И». Селекторы, применяемые к одному элементу, в этом случае пишутся без пробелов:</p>
                    <p>.class1.class2 { }</p>
                    <p>Стили будут применяться ко всем элементам, которые одновременно имеют класс class1 и class2. Ведь это же не новость для вас, что HTML-элементы могут одновременно иметь несколько классов. Например:</p>
                    <p>&lt;div class="class1 class2"&gt;Блок с двумя классами&lt;/div&gt;</p>
                    <p>По такому же принципу можно объединять любое количество абсолютно разных селекторов. И чем больше селекторов вы объединяете, тем больше условий должно совпасть для применения стилей. В программировании похожую операцию часто обозначают как &&.</p>

                    <h3>Псевдокласс :not</h3>
                    <p>Псевдокласс :not(селектор) является отрицающим селектором. С его помощью можно выбрать элементы, которые НЕ содержат указанный селектор:</p>
                    <p>li:not(:last-child) { }</p>
                    <p>Этот селектор выберет все теги &lt;li&gt;, НЕ являющиеся последними в их родителе. Псевдокласс :not похож на оператор ! в программировании:</p>
                    <p>if (!selector) { ... }</p>
                    <p>В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной псевдокласс :not, то есть конструкция :not(:not(...)) не сработает. Также в комбинации с :not не применяются:

                        <ul>
                            <li>объединение селекторов: например, li:not(.heart.jack) — некорректный селектор</li>
                            <li>псевдоэлементы: li:not(::after) — неправильная запись</li>
                            <li>селекторы-потомки, групповые селекторы или комбинации: например, нельзя писать li:not(a span) или li:not(a + span)</li>
                        </ul>
                    </p>
                    <p>Отрицающий селектор :not, как и любые другие селекторы, можно комбинировать с другими. Например:</p>
                    <p>li:not(:first-child):not(:last-child) { }</p>
                    <p>Выберет все теги &lt;li&gt;, которые НЕ являются первыми и последними в их родителе. Объединять можно неограниченное количество селекторов.</p>

                    <h3>Псевдокласс :nth-last-child</h3>
                    <p>Псевдокласс :nth-last-child используется для добавления стиля к элементам на основе нумерации в дереве элементов. В отличие от псевдокласса :nth-child, отсчет ведется не от первого элемента, а от последнего. Вот и все различия.</p>

                    <h3>Псевдокласс :first-of-type</h3>
                    <p>Псевдокласс :first-of-type очень похож на :first-child. Он выбирает первый дочерний элемент родителя, только с учетом типа элементов. Например, в этом задании перед списками с картами есть блок с текстом. У списков и у блока с текстом общий родитель — body.
                        <pre>
                            &lt;body>
                            &lt;div class="paper"> … &lt;/div>
                            &lt;ul class="cards"> … &lt;/ul>
                            &lt;ul class="cards"> … &lt;/ul>
                            &lt;/body>
                        </pre>
                    </p>
                    <p>Сравним две записи:
                        <pre>
                            ul:first-child {
                                background-color: #ffffee;
                              }
                              
                              ul:first-of-type {
                                background-color: #ffffee;
                              }
                        </pre>
                    </p>
                    <p>Верхний селектор выбирает первый дочерний элемент в родителе, причем этот элемент должен быть ul. В нашем случае не выберется ничего, потому что первым дочерним элементом body является div. Нижний селектор выбирает первый ul среди всех дочерних ul в своем родителе. В нашем случае будет выбрана первая строка с картами.</p>

                    <h3>Псевдокласс :last-of-type</h3>
                    <p>В предыдущем задании мы рассмотрели псевдокласс :first-of-type. Псевдокласс :last-of-type работает аналогично, только выбирает последний дочерний элемент родителя с учетом типа.</p>

                    <h3>Псевдокласс :last-of-type</h3>
                    <p>Мы рассмотрели псевдокласс :first-of-type. Псевдокласс :last-of-type работает аналогично, только выбирает последний дочерний элемент родителя с учетом типа.</p>

                    <h3>Псевдокласс :nth-of-type</h3>
                    <p>Псевдокласс :nth-of-type работает почти так же, как и :nth-child. Разница заключается в том, что он учитывает тип элемента. Еще пример. Если в текущем задании мы используем такие селекторы:
                        <pre>
                            ul:nth-child(2) { }
                            ul:nth-of-type(2) { }
                        </pre>
                    </p>
                    <p>То верхний cелектор выберет второй по счёту дочерний элемент и этот элемент должен быть ul. В нашем случае выберется первая строка карт. А нижний селектор выберет второй по счету ul среди дочерних ul. В нашем случае выберется вторая строка карт.</p>
                    <p>Вот неплохая <a href="https://css-tricks.com/the-difference-between-nth-child-and-nth-of-type/">дополнительная статья</a> о различиях :nth-child и :nth-of-type </p>

                    <h3>Псевдокласс :nth-last-of-type</h3>
                    <p>Наверняка, вы и сами уже прекрасно догадались, как будет работать :nth-last-of-type. Элементы выбираются по их расположению, отсчет ведется от конца, учитывается тип элемента. Пример записи:</p>
                    <p>ul:nth-last-of-type(2) { }</p>
                    <p>Когда набор элементов не очень большой, все эти псевдоклассы :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type можно легко заменить один другим. На более сложных структурах зачастую бывает удобнее использовать только определённые из них. Например, когда нужно выделять второй элемент с конца, но количество элементов в списке изменяется.</p>

                    <h3>Cелектор последующих элементов</h3>
                    <p>Ранее мы уже рассматривали соседние селекторы, которые записываются как селектор1 + селектор2. Есть похожий селектор селектор1 ~ селектор2. Стили применятся к элементу, подходящему под селектор2, только если перед ним расположен элемент, подходящий под селектор1. Отличие от соседнего селектора состоит в том, что между элементами селектор1 и селектор2 могут находиться другие элементы. Поэтому будем называть селектор1 ~ селектор2 селектором следующих элементов. Сравним:
                        <pre>
                            &lt;ul class="cards">
                            &lt;li class="king diamond">
                            &lt;li class="queen heart">
                            &lt;li class="jack spade">
                            &lt;li class="ace heart">
                            &lt;li class="king club">
                            &lt;/ul> 
                        </pre>
                        <pre>
                            .queen.heart + li {
                                background-color: #ffff99;
                              }
                              
                              .king.diamond ~ li {
                                background-color: #99ddff;
                              } 
                        </pre>
                    </p>
                    <p>В первом случае выделится одна карта, расположенная сразу за червовой дамой, то есть пиковый валет. Во втором случае выделятся все карты, которые стоят за бубновым королем, то есть червовая дама, пиковый валет, червовый туз и трефовый король.</p>

                    <h3>Псевдокласс :empty</h3>
                    <p>Псевдокласс :empty, выбирает только те теги, у которых нет дочерних элементов (в том числе текстовых узлов). Учтите, что даже переход на новую строку считается текстовым узлом, помните об этом в процессе проектирования структуры страницы.
                        <pre>
                            ul:empty {
                                ...
                              }
                        </pre>
                    </p>
                    <p>В данном случае выберутся все пустые элементы ul</p>

                    <h3>Псевдокласс :only-child</h3>
                    <p>Псевдокласс :only-child пригодится, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.
                        <pre>
                            li:only-child {
                                ...
                              }
                        </pre>
                    </p>
                    <p>Сработает, когда этот &lt;li> в списке единственный. Cелектор :only-child эквивалентен селектору elem:last-child:first-child.</p>

                    <h3>Псевдокласс :only-of-type</h3>
                    <p>Псевдокласс :only-of-type работает почти так же, как и :only-child. Отличие состоит в том, что он учитывает тип элемента.
                        <pre>
                            p:only-of-type {
                                ...
                              }
                        </pre>
                    </p>
                    <p>В данном случае стили будут применены к элементу p, если это единственный p внутри своего родителя.</p>

                    <h3>Псевдоэлемент ::before</h3>
                    <p>Псевдоэлемент before позволяет с помощью CSS добавить псевдотег внутрь другого элемента и оформить его. Cодержимое псевдотега задаётся с помощью свойства content.
                        <pre>
                            &lt;div class="queen heart">
                            &lt;em>Дама&lt;/em>
                            &lt;/div>
                        </pre>
                    </p>
                    <p>Добавим CSS-правило с необычным селектором с двойным двоеточием:
                        <pre>
                            .heart::before { content: "Черви"; }
                        </pre>
                    </p>
                    <p>И HTML изменится вот так:
                        <pre>
                            &lt;div class="queen heart">
                            &lt;before>Черви&lt;/before>
                            &lt;em>Дама&lt;/em>
                            &lt;/div>
                        </pre>
                    </p>
                    <p>Но! Исходный HTML-код не изменится, тег &lt;before> не попадёт в код страницы, а будет «виртуально» существовать где-то в браузере. Поэтому мы и используем приставку псевдо. Ведёт себя псевдотег так же, как обычный &lt;span> с текстом. Ему можно задавать дополнительные стили, например:
                        <pre>
                            .heart::before {
                                content: "Черви";
                                color: red;
                              } 
                        </pre>
                    </p>
                    <p>Чтобы псевдоэлемент появился, ему необходимо задать свойство content. Достаточно даже пустой строки в значении свойства — content: "";.</p>

                    <h3>Псевдоэлемент ::after</h3>
                    <p>Псевдоэлемент after аналогичен before. Отличие заключается в том, что он добавляет псевдотег не в начало, а в конец элемента. Например:
                        <pre>
                            .heart::after { content: "Черви"; }
                        </pre>
                    </p>
                    <p>Даст такой результат:
                        <pre>
                            &lt;div class="queen heart">
                            &lt;em>Дама&lt;/em>
                            &lt;after>Черви&lt;/after>
                            &lt;/div>
                        </pre>
                    </p>
                    <p>Псевдоэлементы before и after можно использовать одновременно. Это означает, что с помощью CSS вы можете добавить к любому элементу на странице два псевдоэлемента. Обратите внимание, что псевдоэлементы пишутся с двойным двоеточием. Этим они отличаются от псевдоклассов, которые используют одинарное двоеточие.</p>

                    <h3>Позиционирование псевдоэлементов</h3>
                    <p>Вы можете задавать псевдоэлементам любые CSS-свойства. Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее. Этими возможностями особенно часто пользуются при создании различных декоративных эффектов. Это очень удобно. Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку. Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.</p>

                    <h3>Псевдоэлементы ::first-line и ::first-letter</h3>
                    <p>Псевдоэлемент first-line задает стиль первой строки форматированного текста. Длина этой строки зависит от многих факторов, таких как используемый шрифт, размер окна браузера, ширина блока, языка и так далее. В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона. Пример использования:
                        <pre>
                            p::first-line { } 
                        </pre>
                    </p>
                    <p>Аналогично псевдоэлемент first-letter определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном. Пример использования:
                        <pre>
                            p::first-letter { } 
                        </pre>
                    </p>



                    
                    
                    <p>/* комментарий CSS */</p>
                    <p>font-size: 16px; - размер шрифта</p>
                    <p>text-shadow: 2px 2px 0 #cccccc; - тень текста</p>
                    <p>color: #cccccc - цвет текста</p>
                    <p>text-decoration: line-through; - зачеркнутый текст</p>
                    <p>padding: 10px; - внутренний отступ (от рамки элемента до содержания)</p>
                    <p>background-color: #cccccc; - цвет фона элемента</p>
                    <p>border-left-width: 10px; - ширина рамки элемента слева</p>
                    <p>font-family: главный, запасной, запасной; - установка шрифта</p>
                </article>
            </section>    
        </main>
    </body>
</html>
